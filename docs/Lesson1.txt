1. Настройка окружения.

Нам нужен фундамент на котором мы начнем создание нашей ОС. Во-первых, предполагается что Вы используется *nix систему с набором утилит GNU. Под windows Вы можете использовать Cygwin, однако тогда написание сценариев сборки полностью на Вашей совести. Также у Вас должен быть установлен загрузчик GRUB2 и должна работать команда grub2-mkrescue.

1.1. Структура каталога
У меня структура каталога следующая:

[code]
gOWNOS
 |
 +-- src
 |
 +-- docs
[/code]

Все Ваши файлы с исходными кодами помещаются в каталога src, а вся документация (Вы же собираетесь писать документацию!?) помещается в каталог docs.

1.2. Компиляция
Примеры, приводимые в данном цикле статей, должны прекрасно компилироваться с набором утилит GNU (gcc,ld,gas и т.д.). Примеры исходных кодов на языке ассемблера написаны с использованием Intel синтаксиса. Для ассемблирования этих файлов Вам потребуется Netwide Assembler (Вообще я поклонник синтаксиса AT&T, но поддамся в данном случае мнению большинства).

Этот цикл статей не описывает вопросы написания загрузчика. В качестве загрузчика мы будем использовать GRUB. Далее будет описано как при помощи GRUB2 создать ISO образ загрузочного диска для запуска нашей ОС.

1.3. Запуск
Для запуска и тестирования ОС Вам не обязательно иметь под рукой свободную машину. Вы можете использовать любой эмулятор по своему усмотрению. Примеры должны хорошо работать на VirtualBox и QEMU.

1.4. Вспомогательные скрипты
Некоторые действия, такие как сборка ядра и создание загрузочного диска, нам придется повторять очень часто. Автоматизируем эти процессы.

1.4.1. Makefile
[code]
# Original file taken from JamesM's tutorials
# The C and C++ rules are already setup by default.
# The only one that needs is the assembler 
# as we use nasm instead of GNU as

OBJS=boot.o

CFLAGS=
LDFLAGS=-Tlink.ld
ASFLAGS=-felf

all: $(OBJS) link

clean:
	-rm *.o kernel

link:
	ld $(LDFLAGS) -o kernel $(OBJS)

.s.o:
	nasm $(ASFLAGS) $<
[/code]

Makefile скомпилирует каждый файл в OBJS, затем слинкует их вместе в ELF-формате. В качестве скрипта линковки используется link.ld.

1.4.2. Link.ld
[code]
/* Link.ld -- Linker script for the kernel - ensure everything goes in the */
/*            Correct place */
/*            Original file taken from Bran's Kernel Development */
/*            tutorials: http://www.osdever.net/bkerndev/index.php */

ENTRY(start)
SECTIONS
{
	.text 0x100000 :
	{
		code = .; _code = .; __code = .;
		*(.text)
		. = ALIGN(4096);
	}

	.data :
	{
		data = .; _data = .; __data = .;
		*(.data)
		*(.rodata)
		. = ALIGN(4096);
	}

	.bss :
	{
		bss = .; _bss = .; __bss = .;
		*(.bss)
		. = ALIGN(4096)
	}

	end = .; _end = .; __end = .;
}
[/code]

Этот скрипт сообщает линковщику как настроить наше ядро. В начале он сообщает линковщику, что точкой входа в нашем исполняемом файле будет адрес с меткой 'start'. Затем он сообщает линковщику, что секция .text (в ней располагается весь наш код) должна располагаться первой и начнаться с адреса 0x100000 (1 МБ). Секции .data (содержащая инициализированные статические переменные) и .bss (содержащая неинициализированные статические переменные) должны располагаться следом, и быть выравнены по границе страницы (ALIGN(4096)). GCC также добавляет специальную секцию .rodata, в которой располагаются инициализированные данные предназначенные только для чтения, например константы. Для простоты просто совместим эту секцию с секцией .data.

1.4.3. update_image.sh
Простой скрипт на Bash, который создаст ISO образ с нашим ядром и GRUB.
[code]
#!/bin/bash

mkdir iso
mkdir -p iso/boot/grub

cp kernel iso/
cp grub.cfg.example iso/boot/grub/grub.cfg

grub2-mkrescue --output=kernel.iso iso

rm -rf iso
[/code]

1.4.4. grub.cfg.example
Этот файл используется загрузчиком GRUB для создания меню запуска и дальнейшей загрузки ядра.
[code]
insmod iso9660
insmod part_msdos

set default=0
set timeout=2

insmod ext2

menuentry "Kernel" {
	multiboot ($root)/kernel
}
[/code]
